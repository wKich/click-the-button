---
revealOptions:
  transition: slide
  controls: false
---



# CLICK THE BUTTON

## The hard way

Дмитрий Лазарев (вниз)

Note: Меня зовут Дмитрий Лазарев. Сегодня я вам расскажу про то как иногда бывает трудно просто кликнуть по кнопке. Но сначала немного о обо мне.

---

![](./logo-kontur.svg)<!-- .element width="100%" -->

Note: Я работаю тим лидом в одной и команд Контура. Возможно вы в курсе что такое Контур и чем мы занимается. Если нет, то Контур занимается разработкой продуктов для электронного документооборота, электронной отчетности и сервисов для предпринимателей и бухгалтеров. Сейчас в Контуре имеется порядка 30 различных продуктов для бизнеса. Наша цель облегчить взаимодействие с государством и сделать работу наших клиентов комфортной. Продукт над которым работает наша команда называется Контур.Экстерн

---

![](./logo-extern.svg)<!-- .element width="100%" -->

Note: Экстерн — основный и самый большой продукт Контура. Основной задачей Экстерна является предоставление удобного сервиса отчетности в контролирующие органы, такие как ФНС, РосСтас, ПФР, ФСС и тд. (Раскрыть?) В разработке Экстерна принимают участие куча команд. Одной из таких команд является команда Формы.

---

![](./logo-forms.png)

Note: Как можно догадаться по названию, команда Форм, занимается формами. Неожиданно, да? На текущий момент у нас реализовано более 300 форм и их кол-во продолжает расти. Может показаться, что у нас много рутины и сплошная бизнес-лапша. Смею вас заверить, что много интересных задач связанных с кодогенерацией, большими объемами и оптимальными авторасчетами. На фронте мы разрабатываем веб версию редактора форм отчетности, предоставляющий пользователю прямо в браузере открыть отчет в удобном и современном интерфейсе. 

---

![](./knpro.png)

Note: Так выгляди небольшая часть одной из форм для отчетности декларации по НДС. Но давайте вернемся к теме моего рассказа.

---

![](./one-does-not-simply.jpg)

Note: Нельзя так просто взять и кликнуть по кнопке, особенно если в тестах хочется делать честные клики, а сами тесты были простые и быстрые. Чтобы лучше представлять в чем заключается проблема, я расскажу немного про тесты, какие они бывают и их особенности. А поможет нам в этом вот этот чувак.

---

![](./mike-cohn.jpg)

Note: Этого чувака зовут Майк Кон. Кто использует у себя в команде скрам или аджайл, возможно знают его. Он является одним из тех кто создал гибкую методологию разработки Scrum, а так же является автором книги про Scrum. В своей книге он рассказывает про концепцию Тестовой пирамиды.

---

## The Test Pyramid

![](./test-pyramid.svg)

Note: Тестовая пирамида представляет собой метафору, прекрасно иллюстрирующую различные уровни тестирования и то какое кол-во тестов должно быть на каждом уровне. Конечно в реальных проектах разделение всегда несколько сложнее чем это представлено в пирамиде тестов и градация не такая четкая. Но обычно все тесты можно разделить на 3 категории (юнит тесты, интеграционные и end-to-end). При движении вверх по пирамиде растет размер тестов и то кол-во кода, которое может покрыть один тест, вместе с этим растет стоимость поддержки и время выполнения. Рассмотрим каждый из уровней подробнее.

---

## Unit tests TODO

![](./unit-tests.svg)

Note: Начнем с самого низа пирамиды, с юнит тестов. Юнит тесты это самый простой вид тестов, который легко ложится в концепцию TDD. Отличительной особенностью этих тестов является то что с помощью них изолированно от всего остального проекта тестируется очень маленький кусочек кода. Примером может служит тест на функцию того что на определенном наборе входных параметров, она должна возвращать конкретнные значения. Или тест на метод класса, при вызове которого, должны просходить вызовы определенных функций с соответствующими аргументами. Из этого всего можно выделить преимущества и недостатки юнит тестов. (Перефразировать про redux)

---

## Unit tests TODO

Плюсы/Минусы

Плюсы:

- Простые, быстрые, стабильные
- TDD, быстрые, стабильные, легко поддерживать

Минусы:

- Низкое покрытие, невозможно протестировать взаимодействие, могут ломаться при рефакторинге
- низкое покрытие, бесполезны после рефакторинга

Note: Простота, переход на интеграционные тесты с взаимодействия

---

## Integration tests

![](./integration-tests.svg)

Note: Интеграционные тесты, находятся на следующему уровне пирамиды тестов и отличаются от юнит тестов тем что лишены этого недостатка. Можно сказать, что если юнит тест отвечает на вопрос "Как код должен работать?", то интеграционные тесты в большей степени говорят "Что код должен делать?". То есть, интеграционным тестом может считать такой тест, который проверяет, что при клике на кнопку на сервер уходит запрос. Из этого можно сделать некоторый вывод.

---

## Integration tests TODO

Плюсы/минусы

Плюсы:

- Тестируется взаимодействие
- хорошее покрытие, быстрые, стабильные

Минусы:

- Плохо подходят под TDD, не позволяют тестировать сценарии (переход)
- нет пользовательских сценариев, поддержка чуть сложнее чем Unit

Note: Переход?

---

## End-to-End (E2E) tests

![](./e2e-tests.svg)

Note: End-to-end тесты взаимодействуют целиком со всем приложением, как если бы с ним взаимодействовал реальный пользователь. Это позволяет тестировать продуктовые сценарии, например для интернет магазина таким сценарием будем: регистрация, выбор товара, добавление его в корзину и оформление доставки. Для таких тестов необходимо разворачивать реальное приложение, инициализировать БД с некоторым набором начальных данных. Это приводит к тому что подготовка окружения занимает значительное время, иногда даже больше чем время выполнения самого теста. Подытожим плюсы и минусы e2e тестов:

---

## End-to-End (E2E) tests TODO

Плюсы/Минусы

Плюсы:

- Пользовательские сценария, большое покрытие
- пользовательские сценарии, огромное покрытие, независят от рефакторинга

Минусы:

- Долгие, сложные в поддержке, нестабильные
- медленные, нестабильные, тяжело поддерживать

Note: Переход?

---

## Итоги

- Честные клики <!-- .element class="fragment" data-fragment-index="1" -->
- Тестирование взаимодействия <!-- .element class="fragment" data-fragment-index="2" -->
- Достаточно быстрые <!-- .element class="fragment" data-fragment-index="3" -->
- Относительно стабильные <!-- .element class="fragment" data-fragment-index="4" -->

Note: Но вернемся к нашей изначальной проблеме. Нам необходимо кликать по кнопке и тестировать некоторое взаимодействие, при этом хотелось не потерять сильно в скорости выполнения тестов, а также обеспечить приемлемый уровень стабильности. Очевидно, что юнит тесты нам не подходят, они не позволяют тестировать взаимодействие. e2e тесты дают нам честные клики и в целом мы можем протестировать взаимодействие, но такие тесты не подходят из-за своей нестабильности и скорости выполнения. Из-за чего нам придется остановить свой выбор на интеграционных тестах, котоыре в большей мере отвечают нашим требованиям. Теперь нам необходимо выбрать инструмент для тестирования, так как в формах мы используем React, то первое что может придти на ум, использовать популярную библиотеку для тестирования React компонентов Enzyme.

---

## Enzyme

![](./logo-react.svg) <!-- .element style="width: 55%; float: left;" -->

![](./logo-airbnb.svg)<!-- .element style="width: 40%; float: left;" -->

http://airbnb.io/enzyme/

Note: Enzyme — это библиотечка от парней из компании Airbnb, занимающейся предоставлением сервиса для шаринга жилья. Enzyme предоставляет удобное API для тестирования React компонентов, позволяет легко протестировать как ведет себя компонент при изменении props/state, вызовы life-cycle методов, разметку.

---

## Enzyme

```typescript
const wrapper = mount(<AwesomeButton />)
wrapper.find('button').simulate('click')
```

<!-- .element class="fragment" data-fragment-index="1" -->

```typescript
// Тоже самое что и
wrapper.find('button').prop('onClick')()
```

<!-- .element class="fragment" data-fragment-index="2" -->

```typescript
// Работать не будет
wrapper.simulate('click')
```

<!-- .element class="fragment" data-fragment-index="3" -->

- <!-- .element class="fragment" data-fragment-index="4" --> Нечестные клики, вызов `props.onClick`
- <!-- .element class="fragment" data-fragment-index="4" --> Завязка на внутреннюю разметку

Note: К примеру у нас есть крутая кнопка, со сложной разметкой внутри, некоторой логикой и где-то там внутри есть взаимодействие с APIшкой. И нам хочется протестировать поведение при клике. Чтобы это сделать, нам нужно найти элемент button и эмулировать событие click на данном элементе. Кажется, что всё хорошо, за исключением того, что в тестах появляется знание о внутреней разметке компонента. Но, на самом деле вызов simulate('click') ничто иное, как просто вызов функции onClick из props нашей кнопки, именно так работает подкапотом enzyme по словам авторов, в следующей версии они планируют удалить метод simulate, за его неявное поведение. В результате мы имеем, нечестные клики и завязку на внутрености компонента. К сожаление, оба этих пункта не дают нам использовать enzyme в наших тестах. Попробуем на этот раз взять TestCafe.

---

![](./logo-testcafe.png) <!-- .element style="background: #fff; padding: 20px" -->

http://devexpress.github.io/testcafe/

Note: ОПИСАНИЕ Штука достаточно удобная. Поддержка TypeScript'а, возможность использовать async/await, быстрый старт. Приятное API и встроенные ассерты. А самое главное, так как это инструмент для e2e тестов, честные клики.

---

## TestCafe

Добавить в код подключение к странице. Простой пример. И сложный на другом слайде, пример с проблемами использования для интеграционных тестов (Разные компоненты, разные ссылки). Не говорить про spy/mock

```typescript
test('Click the button', async t => {
    await t.click('[data-prop-tid=button]')
    // ...
})
```

- Удобная штука для e2e тестов
- Можно инжектить код на клиент
- Мокать и навешивать spy, слишком сложно

Note: Но как и Selenium, писать интеграционные тесты с его помощью достаточно сложно. В виду того что нам необходимо проверять то как компонент взаимодействует с формой, а не форму целиком.

---

## TestCafe

Диаграмка

Рассказать что testcafe хороший, но для других задач, в нашем кэйзе не подходит. Внутри устроен так, переход к Dom events

TestCafe в отличии от Selenium используется URL-Rewriting proxy. Это прокси инжектит специальные скрипты, которые эмулируют пользовательские действия. Так как TestCafe внутри себя содержит скрипты позволяющие эмулировать пользовательские действия, почему бы нам не попробовать самим сделать что-то подобное с помощью DOM Events.

---

## DOM Events

Мы опять вернулись к проблеме поиска button. Дописать переход на CDP

```typescript
it('Click the button', () => {
    const button = document
    	.querySelector('[data-prop-tid=button]')
    button.querySelector('button').click()
    // Или
    const event = new MouseEvent('click')
    button.querySelector('button').dispatchEvent(event)
    
    // ...
})
```

- Всплытие и tid навешивается на label
- Завязка на внутреннюю разметку

Note: Тут всё достаточно понятно. Более-менее честные клики, нет сложностей в написании интеграционных тестов, но нам снова как и с Enzyme приходится завязываться на внутренюю разметку компонентов. Кажется что выхода нет и мы вынуждены будем или писать кучу E2E тестов, которые будет больно поддерживать, они будут очень долго ходить и постоянно падать или полагаясь на unit тесты надеятся, что в результате очередного рефакторинга мы ничего не забыли и все модули правильно используют внутренее API друг друга. Но на самом деле не всё так плохо. Выход есть, и он называется Chrome DevTools Protocol.

---

## Chrome DevTools Protocol

![](./logo-chrome.png)

https://chromedevtools.github.io/devtools-protocol/

Note: CDP — это низкоуровневое API для управления браузеров Chrome и ему подобных, построеное поверх вебсокетов. Позволяет делать множество интересных вещей с браузером, инспектировать и взаимодействовать с DOM, отлаживать скрипты, заниматься профилированием, работать с сетью, а так же эмулировать пользовательские действия. Попробуем воспользоваться.

---

## Chrome DevTools Protocol

Код запуска с флагом

Note:  Чтобы иметь возможность удаленно подключится к браузеру, необходимо запустить хром с флагом remote-debugging-port.

---

Появление с анимашкой, PageId.

Находим нашу кнопку

Кликаем по ней

(Возможно 3 слайда, опции для mouse event)

```typescript
const ws = new WebSocket(
    `ws://localhost:9222/devtools/page/${PageId}`)
const send = data =>
	ws.send(JSON.stringify({ id: uuid(), ...data }))
```

```typescript
send({method: 'DOM.getDocument', params: {}})
send({
    method: 'DOM.querySelector',
    params: {nodeId: 1, selector: '[data-prop-tid=button]'}})
```

```typescript
send({method: 'DOM.getBoxModel', params: { nodeId: 23 }})
send({
    method: 'Input.dispatchMouseEvent',
    params: { type: 'mousePressed', x: 40, y: 357,
               button: 'left', clickCount: 1 }})
send({
    method: 'Input.dispatchMouseEvent',
    params: { type: 'mouseReleased', x: 40, y: 357,
             button: 'left', clickCount: 1 }})
```

Note: У нас выходит что-то такое. В первой строке мы подключаемся по вебсокетам для того чтобы взаимодействовать с определенной страницей (под страницей может выступать вкладка, devtools браузера, экстеншоны). Далее мы получаем nodeId документа, тут нам повезло и документ имеет nodeId: 1. После этого применяем селектор, который нам возвращает nodeId найденного элемента. После этого запрашиваем BoxModel для этого элемента и получаем размеры и координаты кнопки. Две последние команды нажимают/отпускают левую кнопку мыши по координатам внутри кнопки. Как видно, получается очень громоздко. И вместо того чтобы писать свою обертку воспользуемся уже готовой библиотекой.

---

![](./logo-puppeteer.png)

<!-- .element style="background: #fff; width: 40%; padding: 20px; display: inline-block" -->

Note: На самом деле существует достаточно много реализаций высокоуровнего API над CDP. Я выбрал Puppeteer из-за того что он предоставляет очень удобное API для работы с DOM.

---

## Puppeteer

- Хорошее и удобное API, но...
- Не работает в браузере из коробки

Note: Единственным недостатком в нашем случае является то что Puppeteer внутри себя запускает хром и подключается к нему. Нам же необходимо уметь подключаться к уже запущенному инстансу браузера. Поэтому напишем свою небольшую инициализацию.

---

Пояснить что за урл. Пояснить про инстанс (быть готовым). Разбить на слайды

```typescript
const response =
    await fetch('http://localhost:9222/json/version')
const data = await response.json()
// Ответ в json
```

```typescript
import { Connection } from 'puppeteer/lib/Connection'
import Browser from 'puppeteer/lib/Browser'

const connection = await Connection
	.createForWebSocket(data.webSocketDebuggerUrl)
const browser = await Browser
    .create(connection, { appMode: true })
const pages = await browser.pages()
```

```typescript
// Disables network tracking,
// prevents network events from being sent to the client
// NOTE Because we don't want crash browser under events flood
pages.forEach(p => p._client.send('Network.disable', {}))
```

Note: Тут мы получаем вебсокет урл для подключения. Подключаемся и запрашиваем доступные на данный момент странички. И в конце для каждой странички отключаем обработку сетевых событий. Тут хотелось бы пояснить, для чего это нужно. Как изначально я говорил, наша задача писать интеграционные тесты, а это значит, что код тестов выполняется на странице в браузере. Что в свою очередь ведет к тому что подключаться к браузеру необходимо со страницы самого браузера, чтобы управлять браузером находясь в браузере. Взрыв мозга. Но так как мы должны работать с определенной страницей, нам каким-то образом нужно выяснить какая страница относится к текущей вкладке в которой мы сейчас находимся.

---

```typescript
const page = await new Promise(resolve => {
  const expectedGuid = uuid()
  const findCurrentPage = index => async msg => {
    if (msg.type() != 'debug') return
    const [firstArg] = msg.args()
    const receivedGuid = await firstArg.jsonValue()
    if (receivedGuid == expectedGuid) {
      pages[index].removeAllListeners('console')
      resolve(pages[index])
    }
  }
  pages.forEach((p, index) =>
                p.on('console', findCurrentPage(index)))
  console.debug(expectedGuid)
})
```

Note:

---

Пример теста. Код. Повторить пробему

```typescript
it('Should dispatch action with value', async () => {
  const { form } = render(
      <DatePicker path={'a/b'} tid={'datepicker'} />)
  const selector = '[data-prop-tid=datepicker]'
  await devtools.click(selector)
  await devtools.type(selector, '23102018')
  await devtools.mouse.click(0, 0)
  
  expect(form.store.dispatch)
    .to.have.been.calledWithExactly({
      type: UPDATE_MODEL,
      payload: { path: 'a/b', field: 'value',
        value: '23.10.2018' },
    })
})
```



---

Фотка, ФИО, рабочее мыло

Всё что ниже выкинуть

![](./click-the-button.svg)