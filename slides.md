---
revealOptions:
  transition: slide
---



# CLICK THE BUTTON

## The hard way

Дмитрий Лазарев (вниз опустить)

Note: Меня зовут Дмитрий Лазарев. Сегодня я вам расскажу про то как иногда бывает трудно просто кликнуть по кнопке. Но сначала немного о обо мне.

---

![](./logo-kontur-white.svg)<!-- .element width="100%" -->

Note: Я работаю тим лидом в одной и команд Контура. Возможно вы в курсе что такое Контур и чем мы занимается. Если нет, то Контур занимается разработкой продуктов для электронного документооборота, электронной отчетности и сервисов для предпринимателей и бухгалтеров. Сейчас в Контуре имеется порядка 30 различных продуктов для бизнеса. Наша цель облегчить взаимодействие с государством и сделать работу наших клиентов комфортной. Продукт над которым работает наша команда называется Контур.Экстерн

---

![](./logo-extern-white.svg)<!-- .element width="100%" -->

Note: Экстерн — основный и самый большой продукт Контура. Основной задачей Экстерна является предоставление удобного сервиса отчетности в контролирующие органы, такие как ФНС, РосСтас, ПФР, ФСС и тд. (Раскрыть?) В разработке Экстерна принимают участие куча команд. Одной из таких команд является команда Формы.

---

![](./logo-forms.png)

Note: Как можно догадаться по названию, команда Форм, занимается формами. Неожиданно, да? На текущий момент у нас реализовано более 300 форм и их кол-во продолжает расти. Может показаться, что у нас много рутины и сплошная бизнес-лапша. Смею вас заверить, что много интересных задач связанных с кодогенерацией, большими объемами и оптимальными авторасчетами. На фронте мы разрабатываем веб версию редактора форм отчетности, предоставляющий пользователю прямо в браузере открыть отчет в удобном и современном интерфейсе. 

---

![](./knpro.png)

Note: Так выгляди небольшая часть одной из форм для отчетности декларации по НДС. Но давайте вернемся к теме моего рассказа.

---

![](./one-does-not-simply.jpg)

Note: Нельзя так просто взять и кликнуть по кнопке, особенно если в тестах хочется делать честные клики, а сами тесты были простые и быстрые. Чтобы лучше представлять в чем заключается проблема, я расскажу немного про тесты, какие они бывают и их особенности. А поможет нам в этом вот этот чувак.

---

![](./mike-cohn.jpg)

Note: Этого чувака зовут Майк Кон. Кто использует у себя в команде скрам или аджайл, возможно знают его. Он является одним из тех кто создал гибкой методологии разработки Scrum, а так же является автором книги про Scrum. В своей книге он рассказывает про концепцию Тестовой пирамиды.

---

## The Test Pyramid

![](./test-pyramid.svg)

Note: Тестовая пирамида представляет собой метафору, прекрасно иллюстрирующую различные уровни тестирования и то какое кол-во тестов должно быть на каждом уровне. Как можно увидеть. Пирамида состоит из 3-х уровней (юнит тесты, интеграционные и end-to-end).

Какие тесты бывают (Unit, Integration, E2E). Unit — Плюсы: TDD, быстрые, стабильные, легко поддерживать. Минусы: низкое покрытие, бесполезны после рефакторинга. E2E — Плюсы: пользовательские сценарии, огромное покрытие, независят от рефакторинга. Минусы: медленные, нестабильные, тяжело поддерживать. Integration — Плюсы: хорошее покрытие, быстрые, стабильные. Минусы: нет пользовательских сценариев, поддержка чуть сложнее чем Unit. Почему именно Integration. Много сгенерированных форм, тяжело поддерживать столько E2E тестов, медленные. Unit тесты не дают достаточного уровня покрытия. Золотая середина.

---

## Unit tests

![](./test-pyramid-unit.png) <!-- .element width="661px" height="398px" -->

---

## Unit tests

Диаграмка

Плюсы-минусы с анимашкой

---

## Integration tests

Выделяем этаж

---

##Integration tests

Диаграмка

Плюсы-минусы с анимашкой

---

## E2E tests

Выделяем этаж

---

##E2E tests

Диаграмка

Плюсы-минусы с анимашкой

---

## Итоги

Нужны интеграционные тесты (Раскрыть мысль, куча форм, React -> Enzyme)

Note: Итак. Нам нужны интеграционные тесты на работу компонента/ов внутри формы. Так как мы используем React, то первое что может придти на ум, использовать популярную библиотеку для тестирования React компонентов Enzyme.

---

Пример компонента AwesomeButton (опционально), проговорить, пробуем написать тесты на этот компонент

---

## Enzyme

Логотип, сайт

Note: Enzyme — это такая прикольная штука, которая существенно упрощает написание Unit тестов на компоненты, позволяет легко протестировать как ведет себя компонент при изменении props/state, вызовы life-cycle методов, разметку.

---

##Enzyme

```typescript
const wrapper = mount(<AwesomeButton />)
wrapper.find('button').simulate('click')
```

```
// Тоже самое что и
wrapper.find('button').prop('onClick')()
```

```
// Работать не будет
wrapper.simulate('click')
```

Разбить на section с анимашкой появления. Переписать текст про кнопку (Не нужен DatePicker), она сложная, разметка, лейбл, обработчики.

1. Что это
2. Что подкапотом
3. Просто кликнуть не получится
4. Рассказать почему не будет, именно по этому Enzyme не подходит

- Не честные клики, вызов `props.onClick`
- Завязка на внутреннюю разметку

Note: В каких случаях это плохо. Возьмем для примера DatePicker, компонент чуть более сложный, чем простой input. Внутри себя рисует input, передает ему в onChange свой обработчик, который в свою каким-то образом форматирует/парсит пользовательский ввод (позволяет вводить дату без точек) и вызывает onChange из props с модифицированным значением. Так вот simulate('change') ничто иное, как просто вызов onChange из props нашего DatePicker. Если нам нужно протестировать внутренний обработчик, то нам сначала нужно найти тот input и уже у него вызывать onChange. Попробуем зайти с другой стороны и возьмем уже инструмент для E2E тестирования, а именно TestCafe.

---

## TestCafe

Лого, сайт

Note: Штука достаточно удобная. Поддержка TypeScript'а, возможность использовать async/await, быстрый старт. Приятное API и встроенные ассерты. А самое главное, так как это инструмент для e2e тестов, честные клики.

---

##TestCafe

Добавить в код подключение к странице. Простой пример. И сложный на другом слайде, пример с проблемами использования для интеграционных тестов (Разные компоненты, разные ссылки). Не говорить про spy/mock

```typescript
test('Click the button', async t => {
    await t.click('[data-prop-tid=button]')
    // ...
})
```

- Удобная штука для e2e тестов
- Можно инжектить код на клиент
- Мокать и навешивать spy, слишком сложно

Note: Но как и Selenium, писать интеграционные тесты с его помощью достаточно сложно. В виду того что нам необходимо проверять то как компонент взаимодействует с формой, а не форму целиком.

---

##TestCafe

Диаграмка

Рассказать что testcafe хороший, но для других задач, в нашем кэйзе не подходит. Внутри устроен так, переход к Dom events

TestCafe в отличии от Selenium используется URL-Rewriting proxy. Это прокси инжектит специальные скрипты, которые эмулируют пользовательские действия. Так как TestCafe внутри себя содержит скрипты позволяющие эмулировать пользовательские действия, почему бы нам не попробовать самим сделать что-то подобное с помощью DOM Events.

---

## DOM Events

Мы опять вернулись к проблеме поиска button. Дописать переход на CDP

```typescript
it('Click the button', () => {
    const button = document
    	.querySelector('[data-prop-tid=button]')
    button.querySelector('button').click()
    // Или
    const event = new MouseEvent('click')
    button.querySelector('button').dispatchEvent(event)
    
    // ...
})
```

- Всплытие и tid навешивается на label
- Завязка на внутреннюю разметку

Note: Тут всё достаточно понятно. Более-менее честные клики, нет сложностей в написании интеграционных тестов, но нам снова как и с Enzyme приходится завязываться на внутренюю разметку компонентов. Кажется что выхода нет и мы вынуждены будем или писать кучу E2E тестов, которые будет больно поддерживать, они будут очень долго ходить и постоянно падать или полагаясь на unit тесты надеятся, что в результате очередного рефакторинга мы ничего не забыли и все модули правильно используют внутренее API друг друга. Но на самом деле не всё так плохо. Выход есть, и он называется Chrome DevTools Protocol.

---

## Chrome DevTools Protocol

Логотип, сайт. Кто такой

Note: CDP — это низкоуровневое API для управления браузеров Chrome и ему подобных, построеное поверх вебсокетов. Позволяет делать множество интересных вещей с браузером, инспектировать и взаимодействовать с DOM, отлаживать скрипты, заниматься профилированием, работать с сетью, а так же эмулировать пользовательские действия. Попробуем воспользоваться.

---

##Chrome DevTools Protocol

Код запуска с флагом

Note:  Чтобы иметь возможность удаленно подключится к браузеру, необходимо запустить хром с флагом remote-debugging-port.

---

Появление с анимашкой, PageId.

Находим нашу кнопку

Кликаем по ней

(Возможно 3 слайда, опции для mouse event)

```typescript
const ws = new WebSocket(
    `ws://localhost:9222/devtools/page/${PageId}`)
const send = data =>
	ws.send(JSON.stringify({ id: uuid(), ...data }))
```

```typescript
send({method: 'DOM.getDocument', params: {}})
send({
    method: 'DOM.querySelector',
    params: {nodeId: 1, selector: '[data-prop-tid=button]'}})
```

```typescript
send({method: 'DOM.getBoxModel', params: { nodeId: 23 }})
send({
    method: 'Input.dispatchMouseEvent',
    params: { type: 'mousePressed', x: 40, y: 357,
               button: 'left', clickCount: 1 }})
send({
    method: 'Input.dispatchMouseEvent',
    params: { type: 'mouseReleased', x: 40, y: 357,
             button: 'left', clickCount: 1 }})
```

Note: У нас выходит что-то такое. В первой строке мы подключаемся по вебсокетам для того чтобы взаимодействовать с определенной страницей (под страницей может выступать вкладка, devtools браузера, экстеншоны). Далее мы получаем nodeId документа, тут нам повезло и документ имеет nodeId: 1. После этого применяем селектор, который нам возвращает nodeId найденного элемента. После этого запрашиваем BoxModel для этого элемента и получаем размеры и координаты кнопки. Две последние команды нажимают/отпускают левую кнопку мыши по координатам внутри кнопки. Как видно, получается очень громоздко. И вместо того чтобы писать свою обертку воспользуемся уже готовой библиотекой.

---

## Puppeteer 

Лого, сайт, что такое

Note: На самом деле существует достаточно много реализаций высокоуровнего API над CDP. Я выбрал Puppeteer из-за того что он предоставляет очень удобное API для работы с DOM.

---

##Puppeteer

- Хорошее и удобное API, но...
- Не работает в браузере из коробки

Note: Единственным недостатком в нашем случае является то что Puppeteer внутри себя запускает хром и подключается к нему. Нам же необходимо уметь подключаться к уже запущенному инстансу браузера. Поэтому напишем свою небольшую инициализацию.

---

Пояснить что за урл. Пояснить про инстанс (быть готовым). Разбить на слайды

```typescript
const response =
    await fetch('http://localhost:9222/json/version')
const data = await response.json()
// Ответ в json
```

```typescript
import { Connection } from 'puppeteer/lib/Connection'
import Browser from 'puppeteer/lib/Browser'

const connection = await Connection
	.createForWebSocket(data.webSocketDebuggerUrl)
const browser = await Browser
    .create(connection, { appMode: true })
const pages = await browser.pages()
```

```typescript
// Disables network tracking,
// prevents network events from being sent to the client
// NOTE Because we don't want crash browser under events flood
pages.forEach(p => p._client.send('Network.disable', {}))
```

Note: Тут мы получаем вебсокет урл для подключения. Подключаемся и запрашиваем доступные на данный момент странички. И в конце для каждой странички отключаем обработку сетевых событий. Тут хотелось бы пояснить, для чего это нужно. Как изначально я говорил, наша задача писать интеграционные тесты, а это значит, что код тестов выполняется на странице в браузере. Что в свою очередь ведет к тому что подключаться к браузеру необходимо со страницы самого браузера, чтобы управлять браузером находясь в браузере. Взрыв мозга. Но так как мы должны работать с определенной страницей, нам каким-то образом нужно выяснить какая страница относится к текущей вкладке в которой мы сейчас находимся.

---

```typescript
const page = await new Promise(resolve => {
  const expectedGuid = uuid()
  const findCurrentPage = index => async msg => {
    if (msg.type() != 'debug') return
    const [firstArg] = msg.args()
    const receivedGuid = await firstArg.jsonValue()
    if (receivedGuid == expectedGuid) {
      pages[index].removeAllListeners('console')
      resolve(pages[index])
    }
  }
  pages.forEach((p, index) =>
                p.on('console', findCurrentPage(index)))
  console.debug(expectedGuid)
})
```

Note:

---

Пример теста. Код. Повторить пробему

---

Фотка, ФИО, рабочее мыло

Всё что ниже выкинуть

---

## PROFIT

- Удобное API
- Честные клики и не только
- Работает только в хроме

---

## Bonus

```typescript
const promiseHandler = {
  apply(target, _thisArg, args) {
    return target().then(func => func(...args))
  },
  get(target, prop) {
    return new Proxy(() => target()
      .then(obj => obj[prop]), promiseHandler)
  },
}

const devtools = new Proxy(() => attachDevTools(),
                           promiseHandler)
```

Note:

---

```typescript
it('Should dispatch action with value', async () => {
  const { form } = render(
      <DatePicker path={'a/b'} tid={'datepicker'} />)
  const selector = '[data-prop-tid=datepicker]'
  await devtools.click(selector)
  await devtools.type(selector, '23102018')
  await devtools.mouse.click(0, 0)
  
  expect(form.store.dispatch)
    .to.have.been.calledWithExactly({
      type: UPDATE_MODEL,
      payload: { path: 'a/b', field: 'value',
        value: '23.10.2018' },
    })
})
```

Note:

---

## The End

![](./click-the-button.svg)

https://wkich.github.io/click-the-button/

https://martinfowler.com/bliki/TestPyramid.html

https://chromedevtools.github.io/devtools-protocol/

https://www.youtube.com/watch?v=0GypdsJulKE

Note: Вопросы. Почему button обернут в label — издержки ИЕ8, сейчас скорее всего это уже не нужно, надо проверять. Другой пример combobox, где input отображается в режиме редактирования. Необходимо для того чтобы рисовать значение состоящие из двух полей: код и наименование. data-prop атрибуты