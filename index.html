<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal-md</title>
    <link rel="stylesheet" href="./css/reveal.css">
    <link rel="stylesheet" href="./css/theme/black.css" id="theme">
    <link rel="stylesheet" href="./css/highlight/zenburn.css">
    <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print">
    <link rel="stylesheet" href="./assets/style.css">


</head>

<body>

    <div class="reveal">
        <div class="slides">
            <section data-markdown>
                <script type="text/template">



# CLICK THE BUTTON

## The hard way

<aside class="notes"><p>Представиться. Рассказ про команду (Экстерн, сервис отчетности, формы). Вступительное слово (Насколько трудно кликнуть по кнопке, в тестах)</p>
</aside></script>
            </section>
            <section data-markdown>
                <script type="text/template">
## The Test Pyramid

![](data:image/svg+xml;base64,PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjYxcHgiIGhlaWdodD0iMzk4cHgiIHZlcnNpb249IjEuMSIgY29udGVudD0iJmx0O214ZmlsZSB1c2VyQWdlbnQ9JnF1b3Q7TW96aWxsYS81LjAgKE1hY2ludG9zaDsgSW50ZWwgTWFjIE9TIFggMTBfMTNfNikgQXBwbGVXZWJLaXQvNjA1LjEuMTUgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzEyLjEgU2FmYXJpLzYwNS4xLjE1JnF1b3Q7IHZlcnNpb249JnF1b3Q7OS4wLjImcXVvdDsgZWRpdG9yPSZxdW90O3d3dy5kcmF3LmlvJnF1b3Q7IHR5cGU9JnF1b3Q7Z29vZ2xlJnF1b3Q7Jmd0OyZsdDtkaWFncmFtIGlkPSZxdW90Ozg2OGU2ZTdmLTQ4MzYtN2EyNi1hMzc4LTFmMTQyNjZkZDNhMyZxdW90OyBuYW1lPSZxdW90O1BhZ2UtMSZxdW90OyZndDs3VnRkYzZNMkZQMDFlWXhIWDRCNFRKeWs3Y04yT3BOMitveEJ4c3hpNU1IeXh1bXZyekFTTmtnRWt1WERtU3dQSHJnU0FzNjVPbGRYa20vd2NudjhMUTkybTI4OFl1a05BdEh4QmovY0lPUlNJSDhMdzJ0cElKaVVoamhQb3RJRXpvYm41RDlXR3FHMkhwS0k3Wld0TkFuT1U1SHM2c2FRWnhrTFJjMFc1RGwvcVZkYjh6U3FHWFpCekF6RGN4aWtwdlhmSkJLYjBrb2RjTGIvenBKNG81OE1nU3BaQmVIM09PZUhURDN2Qm1GME9zcmliYURiVXZYM215RGlMeGNtL0hpRGx6bm5vanpiSHBjc0xhQ3R3L2JVVWxxOWQ4NHkwZWNHRkRnZ1hIbkFnOFNqUWJTKzFVMzhDTklEMDk5d2VsUHhxdEVwUG5DbnFyRmNzS09OazJDbHF3UHpwV0QxcWRLREdOOHlrYi9LS3FvaDVEb0xwN3hKK1Era3F2R1hNeHZZVlExdkxwakF2cWU4UUhsQVhMVitSa0dlS0NCNmd1SjJZeUx5Sk1qaTR1citaWk1JOXJ3THdxTG9SZllQYWR1SXJYemFBNVNuT1JlQlNIZ21MMzBncjlkSm1pNTV5bk5weUhoV3RCRHliUkxLeTZKNEwzTCtuZWtLMHA5OGNIZi9nS29TN1o5WVduWXNUK1RYc3J4NGVwTEZxb2xXcWk0cGFmR0VWcEp1SGMrZ0JOSEpLQ0hYUk1rZFdIcDBPVDhsR014SmlYTk5sRHhRaWltWW54STBJU09lUjZKMUNCbkFpRGdFamRkSmJnMUt6bkh1TFY0VWNYVktTRHNsdkxnU1JRendlalBVRVZxd0VWaDBxSm1FSW9lc2ZRZ3hKUkNFYkUxdjhmelIxb2MxUktveDJBVWVGRm5nMFBWK0JnNnlYcTNrRC9JSlhRY092dlc2NFdCWmRGZU04T1JWbUFiN2ZlRnFsMjY2RjBFdWRBMHVXOUsycHlROTEybW94ZFBwc0twRitRSXNNZ2FNWjN5dHBKcDRYd0RxV1B4TDIzS1d5bjcyby80NEc4anFDWC94Ukw1SVJTY0JOVG9ObXZiOGtJZE0zWFE1TXV4b3A5R01SRFJtd21qbVJIajF6Ui9xRXNqd2dWTitnQUJmRjJrQTJ3dFR4TmhSTkwzQW9qdVdHQktrU1Z3b1dpakpaTkorWDNTeFJDWUNkNnBnbTBSUnF6cWVCdm9zVW1xMTVwbXcrVlJoVnlrTzZpMWpQWDFLaHhsb0RzWWdkRTBuUXdOMDJ1YXI5WWd5WTJzWTlIRE5XeDFDRER3SWNDeDQwT0ZGckVlMjhDNFJPOWVZV01mSUxEcjJmcUZ5cHBJbVcyNHNIUS84ZWRpdXBIcGNTTlQrSzJwVWk3L29CaUJ0WlBXdXFWa3VuVWF6NlB5YUpZZWlQV1k1eGh1S05tVnJyUFROVEJiNjVHL0wwL0dlWk9GRExrczdKVzdDQk5vYytid1ZPQlNLVWJEZm5MbzN0S21MeGcyOWlmRUhZa00zY0dQRUJwMmpPSDc5bHI2eG9pS3pyYUhoWW9mQmJvOVU3NHV6cTBqU25HaFZkRDlLTmdKTmdXMDJOU0xkY0pJUTA1TTQxWEREKzMzZkRNREl3cXM3UUFBMjhmRU5mQjdSNDVVUG55NUQxcUJEcVJiM01ablVDMnJtSkkyVnVpSEdUbWFjQWdaMTkwbjhDU2lycXlhc2swWGVJblZZRXJ0WUk2TjB1TjRyZXdZTTRIVFl1ZW83Unp1OG1qbTBIc3RkeXh5SWl5ZVNNMVBOL3NrUzhVdk9hczdYbmh2aWhVUHh4VUZxMU5yVVRtWlB0VHZnUk9JSFRmRjczZ2JGUFZkUDhlVHkxMEo2VndjZFF2Nk10YkJKVmxwK1NzQ2dYbWFaUmNDZ09XMzVoM1MvT0MveitDOHFaSFkzZXRld3pNYmdPTXBrcnA1OVkxRnkySDRDMGthV3ByNDA2c3dSTExEbmdQTmhHVmtndEVDV0JZVWh0TXVZZHU0eE5UZjJiS1VMNjZsMGxlelhWcHg4aTZzUG9WWUdJajJteW9aWDh4S0MxczRQYVU5STZBQ0lOR2R2ZXdDeTN3Uzc0blNkc3FPYVpycnZXb2hxN1BHbzlwN0orNnJKSjMvaHVBQVF6M0VSUVk1TFNWbXVPaThFQzk5MUhPZ2hBckhuWTFnMHF4RkNaRkVhQVNhRUlrOUd4Qll0S3IvbVhaTllwWlBNTlVmWkpMbHoxbXFDNVNzekExeHkyVGVLemJEWEdTSWFvbCs1M3lETFZXMytVVTBmMWdRUFU2Tno2MFdBc1JlcjRDeGoxdzYxbzc1bDQ1UnRvOUFRYW1lTWRYcHNGQnBBN3FwOW5aOUM3dWJaZG5URmNtZG02bjhuV3lsMWJscEkyeXFYWjdHb3dMNTI4YXVjY1JqeDZ4Z0IxOFdQQUV0bnQrMi9IMFgrSnRsZzFGZitMZ0R3TEFBTW9YYk5WekhGYnNtTFhYQ2YwNCtybmRuRCtQSGJtMDRNUHphOG1JeTA0OFFJV1QzV0F3Y0lXUlc2bnlKa3piUERiTGFRSlMvUGYrMHFxNS8vUG9jZi93Yz0mbHQ7L2RpYWdyYW0mZ3Q7Jmx0Oy9teGZpbGUmZ3Q7Ij48ZGVmcy8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC41LDAuNSkiPjxwYXRoIGQ9Ik0gMTM0LjUgMCBMIDQxNC41IDE5OC41IEwgMTM0LjUgMzk3IFoiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzkwYWJkMiIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHRyYW5zZm9ybT0icm90YXRlKDkwLDI3NC41LDE5OC41KSIgcG9pbnRlci1ldmVudHM9Im5vbmUiLz48cGF0aCBkPSJNIDE2MS41IDAgTCA0NDEuNSAxOTguNSBMIDE2MS41IDM5NyBaIiBmaWxsPSJub25lIiBzdHJva2U9IiNhMGM3OGMiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB0cmFuc2Zvcm09InJvdGF0ZSg5MCwzMDEuNSwxOTguNSkiIHBvaW50ZXItZXZlbnRzPSJub25lIi8+PHBhdGggZD0iTSAxODkuNSAwIEwgNDY5LjUgMTk4LjUgTCAxODkuNSAzOTcgWiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZDg4MzgwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgdHJhbnNmb3JtPSJyb3RhdGUoOTAsMzI5LjUsMTk4LjUpIiBwb2ludGVyLWV2ZW50cz0ibm9uZSIvPjxwYXRoIGQ9Ik0gMTYxIDAuNSBMIDQ0MSAxOTkgTCAxNjEgMzk3LjUgWiIgZmlsbC1vcGFjaXR5PSIwLjciIGZpbGw9IiMyMjIyMjIiIHN0cm9rZT0ibm9uZSIgdHJhbnNmb3JtPSJyb3RhdGUoLTkwLDMwMSwxOTkpIiBwb2ludGVyLWV2ZW50cz0ibm9uZSIvPjxwYXRoIGQ9Ik0gNTcgMzM2IEwgNTcgNjkuMSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9Im5vbmUiLz48ZWxsaXBzZSBjeD0iNTciIGN5PSIzMzkiIHJ4PSIzIiByeT0iMyIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjMiIHBvaW50ZXItZXZlbnRzPSJub25lIi8+PHBhdGggZD0iTSA1NyA2Mi4zNSBMIDYxLjUgNzEuMzUgTCA1NyA2OS4xIEwgNTIuNSA3MS4zNSBaIiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ibm9uZSIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDguNSwyNy41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZTsiIHBvaW50ZXItZXZlbnRzPSJhbGwiIHdpZHRoPSI5OSIgaGVpZ2h0PSIyMiIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDIwcHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSk7IGxpbmUtaGVpZ2h0OiAxLjI7IHZlcnRpY2FsLWFsaWduOiB0b3A7IHdpZHRoOiAxMDBweDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgd29yZC13cmFwOiBub3JtYWw7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOmluaGVyaXQ7Ij5TaXplIG9mIHRlc3Q8L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iNTAiIHk9IjIxIiBmaWxsPSIjRkZGRkZGIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjIwcHgiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiPlNpemUgb2YgdGVzdDwvdGV4dD48L3N3aXRjaD48L2c+PHBhdGggZD0iTSAxMDkuMSAzNjMgTCA0OTMuOSAzNjMiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJub25lIi8+PHBhdGggZD0iTSAxMDIuMzUgMzYzIEwgMTExLjM1IDM1OC41IEwgMTA5LjEgMzYzIEwgMTExLjM1IDM2Ny41IFoiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJub25lIi8+PHBhdGggZD0iTSA1MDAuNjUgMzYzIEwgNDkxLjY1IDM2Ny41IEwgNDkzLjkgMzYzIEwgNDkxLjY1IDM1OC41IFoiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJub25lIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjIyLjUsMzY3LjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlOyIgcG9pbnRlci1ldmVudHM9ImFsbCIgd2lkdGg9IjE1OCIgaGVpZ2h0PSIyMiIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDIwcHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSk7IGxpbmUtaGVpZ2h0OiAxLjI7IHZlcnRpY2FsLWFsaWduOiB0b3A7IHdpZHRoOiAxNTlweDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgd29yZC13cmFwOiBub3JtYWw7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOmluaGVyaXQ7Ij4jIE51bWJlciBvZiB0ZXN0czwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI3OSIgeT0iMjEiIGZpbGw9IiNGRkZGRkYiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMjBweCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSI+IyBOdW1iZXIgb2YgdGVzdHM8L3RleHQ+PC9zd2l0Y2g+PC9nPjxwYXRoIGQ9Ik0gMTYxLjUgMCBMIDQ0MS41IDE5OC41IEwgMTYxLjUgMzk3IFoiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2NjY2NjYyIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHRyYW5zZm9ybT0icm90YXRlKC05MCwzMDEuNSwxOTguNSkiIHBvaW50ZXItZXZlbnRzPSJub25lIi8+PHBhdGggZD0iTSAxNjEuNSAyNTkgTCA0NDEuNSAyNTkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2NjY2NjYyIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IjYgNiIgcG9pbnRlci1ldmVudHM9Im5vbmUiLz48cGF0aCBkPSJNIDIyMC41IDE2OSBMIDM4MiAxNjkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2NjY2NjYyIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IjYgNiIgcG9pbnRlci1ldmVudHM9Im5vbmUiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNTguNSwxMzcuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3Qgc3R5bGU9Im92ZXJmbG93OnZpc2libGU7IiBwb2ludGVyLWV2ZW50cz0iYWxsIiB3aWR0aD0iODYiIGhlaWdodD0iMjIiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAyMHB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyBsaW5lLWhlaWdodDogMS4yOyB2ZXJ0aWNhbC1hbGlnbjogdG9wOyB3aWR0aDogODdweDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgd29yZC13cmFwOiBub3JtYWw7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOmluaGVyaXQ7Ij5FMkUgdGVzdHM8L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iNDMiIHk9IjIxIiBmaWxsPSIjRkZGRkZGIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjIwcHgiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiPkUyRSB0ZXN0czwvdGV4dD48L3N3aXRjaD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjcyLjUsOTUuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3Qgc3R5bGU9Im92ZXJmbG93OnZpc2libGU7IiBwb2ludGVyLWV2ZW50cz0iYWxsIiB3aWR0aD0iNTgiIGhlaWdodD0iNDYiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiA0MHB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyBsaW5lLWhlaWdodDogMS4yOyB2ZXJ0aWNhbC1hbGlnbjogdG9wOyB3aWR0aDogNTlweDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgd29yZC13cmFwOiBub3JtYWw7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOmluaGVyaXQ7Ij5CaWc8L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iMjkiIHk9IjQzIiBmaWxsPSIjRkZGRkZGIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjQwcHgiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiPkJpZzwvdGV4dD48L3N3aXRjaD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjU5LjUsMzA1LjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlOyIgcG9pbnRlci1ldmVudHM9ImFsbCIgd2lkdGg9IjgzIiBoZWlnaHQ9IjIyIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMjBweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigyNTUsIDI1NSwgMjU1KTsgbGluZS1oZWlnaHQ6IDEuMjsgdmVydGljYWwtYWxpZ246IHRvcDsgd2lkdGg6IDg0cHg7IHdoaXRlLXNwYWNlOiBub3dyYXA7IHdvcmQtd3JhcDogbm9ybWFsOyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7dGV4dC1hbGlnbjppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0OyI+VW5pdCB0ZXN0czwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI0MiIgeT0iMjEiIGZpbGw9IiNGRkZGRkYiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMjBweCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSI+VW5pdCB0ZXN0czwvdGV4dD48L3N3aXRjaD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjUwLjUsMjYzLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlOyIgcG9pbnRlci1ldmVudHM9ImFsbCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSI0NiIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDQwcHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSk7IGxpbmUtaGVpZ2h0OiAxLjI7IHZlcnRpY2FsLWFsaWduOiB0b3A7IHdpZHRoOiAxMDFweDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgd29yZC13cmFwOiBub3JtYWw7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOmluaGVyaXQ7Ij5TbWFsbDwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI1MCIgeT0iNDMiIGZpbGw9IiNGRkZGRkYiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iNDBweCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSI+U21hbGw8L3RleHQ+PC9zd2l0Y2g+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIyOS41LDIyMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZTsiIHBvaW50ZXItZXZlbnRzPSJhbGwiIHdpZHRoPSIxNDIiIGhlaWdodD0iMjIiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAyMHB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyBsaW5lLWhlaWdodDogMS4yOyB2ZXJ0aWNhbC1hbGlnbjogdG9wOyB3aWR0aDogMTQzcHg7IHdoaXRlLXNwYWNlOiBub3dyYXA7IHdvcmQtd3JhcDogbm9ybWFsOyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7dGV4dC1hbGlnbjppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0OyI+SW50ZWdyYXRpb24gdGVzdHM8L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iNzEiIHk9IjIxIiBmaWxsPSIjRkZGRkZGIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjIwcHgiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiPkludGVncmF0aW9uIHRlc3RzPC90ZXh0Pjwvc3dpdGNoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMjkuNSwxNzguNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3Qgc3R5bGU9Im92ZXJmbG93OnZpc2libGU7IiBwb2ludGVyLWV2ZW50cz0iYWxsIiB3aWR0aD0iMTQyIiBoZWlnaHQ9IjQ2IiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogNDBweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigyNTUsIDI1NSwgMjU1KTsgbGluZS1oZWlnaHQ6IDEuMjsgdmVydGljYWwtYWxpZ246IHRvcDsgd2lkdGg6IDE0M3B4OyB3aGl0ZS1zcGFjZTogbm93cmFwOyB3b3JkLXdyYXA6IG5vcm1hbDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6aW5saW5lLWJsb2NrO3RleHQtYWxpZ246aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246aW5oZXJpdDsiPk1lZGl1bTwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI3MSIgeT0iNDMiIGZpbGw9IiNGRkZGRkYiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iNDBweCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSI+TWVkaXVtPC90ZXh0Pjwvc3dpdGNoPjwvZz48cGF0aCBkPSJNIDU1My4wNyAzMjguNSBMIDUyOC45MyAzMjguNSBMIDUyOC45MyAyODMuNCBMIDUxMy42NSAyODMuNCBMIDU0MSAyNDkuNSBMIDU2OC4zNSAyODMuNCBMIDU1My4wNyAyODMuNCBaIiBmaWxsPSIjOTBhYmQyIiBzdHJva2U9Im5vbmUiIHBvaW50ZXItZXZlbnRzPSJub25lIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTY3LjUsMjg1LjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlOyIgcG9pbnRlci1ldmVudHM9ImFsbCIgd2lkdGg9Ijg3IiBoZWlnaHQ9IjIyIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMjBweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigxNDQsIDE3MSwgMjEwKTsgbGluZS1oZWlnaHQ6IDEuMjsgdmVydGljYWwtYWxpZ246IHRvcDsgd2lkdGg6IDg4cHg7IHdoaXRlLXNwYWNlOiBub3dyYXA7IHdvcmQtd3JhcDogbm9ybWFsOyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7dGV4dC1hbGlnbjppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0OyI+Q292ZXJhZ2U8L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iNDQiIHk9IjIxIiBmaWxsPSIjOTBBQkQyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjIwcHgiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiPkNvdmVyYWdlPC90ZXh0Pjwvc3dpdGNoPjwvZz48cGF0aCBkPSJNIDU1My4wNyAyMzggTCA1MjguOTMgMjM4IEwgNTI4LjkzIDE5Mi45IEwgNTEzLjY1IDE5Mi45IEwgNTQxIDE1OSBMIDU2OC4zNSAxOTIuOSBMIDU1My4wNyAxOTIuOSBaIiBmaWxsPSIjYTBjNzhjIiBzdHJva2U9Im5vbmUiIHBvaW50ZXItZXZlbnRzPSJub25lIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTcwLjUsMTk3LjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlOyIgcG9pbnRlci1ldmVudHM9ImFsbCIgd2lkdGg9IjQ0IiBoZWlnaHQ9IjIyIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMjBweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigxNjAsIDE5OSwgMTQwKTsgbGluZS1oZWlnaHQ6IDEuMjsgdmVydGljYWwtYWxpZ246IHRvcDsgd2lkdGg6IDQ1cHg7IHdoaXRlLXNwYWNlOiBub3dyYXA7IHdvcmQtd3JhcDogbm9ybWFsOyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7dGV4dC1hbGlnbjppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0OyI+VGltZTxiciAvPjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSIyMiIgeT0iMjEiIGZpbGw9IiNBMEM3OEMiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMjBweCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSI+VGltZSZsdDticiZndDs8L3RleHQ+PC9zd2l0Y2g+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU2Ni41LDEwNy41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZTsiIHBvaW50ZXItZXZlbnRzPSJhbGwiIHdpZHRoPSI0MSIgaGVpZ2h0PSIyMiIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDIwcHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMjE2LCAxMzEsIDEyOCk7IGxpbmUtaGVpZ2h0OiAxLjI7IHZlcnRpY2FsLWFsaWduOiB0b3A7IHdpZHRoOiA0MnB4OyB3aGl0ZS1zcGFjZTogbm93cmFwOyB3b3JkLXdyYXA6IG5vcm1hbDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6aW5saW5lLWJsb2NrO3RleHQtYWxpZ246aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246aW5oZXJpdDsiPkNvc3Q8YnIgLz48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iMjEiIHk9IjIxIiBmaWxsPSIjRDg4MzgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjIwcHgiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiPkNvc3QmbHQ7YnImZ3Q7PC90ZXh0Pjwvc3dpdGNoPjwvZz48cGF0aCBkPSJNIDU1My4wNyAxNDguNSBMIDUyOC45MyAxNDguNSBMIDUyOC45MyAxMDMuNCBMIDUxMy42NSAxMDMuNCBMIDU0MSA2OS41IEwgNTY4LjM1IDEwMy40IEwgNTUzLjA3IDEwMy40IFoiIGZpbGw9IiNkODgzODAiIHN0cm9rZT0ibm9uZSIgcG9pbnRlci1ldmVudHM9Im5vbmUiLz48L2c+PC9zdmc+)

<aside class="notes"><p>Какие тесты бывают (Unit, Integration, E2E). Unit — Плюсы: TDD, быстрые, стабильные, легко поддерживать. Минусы: низкое покрытие, бесполезны после рефакторинга. E2E — Плюсы: пользовательские сценарии, огромное покрытие, независят от рефакторинга. Минусы: медленные, нестабильные, тяжело поддерживать. Integration — Плюсы: хорошее покрытие, быстрые, стабильные. Минусы: нет пользовательских сценариев, поддержка чуть сложнее чем Unit. Почему именно Integration. Много сгенерированных форм, тяжело поддерживать столько E2E тестов, медленные. Unit тесты не дают достаточного уровня покрытия. Золотая середина</p>
</aside></script>
            </section>
            <section data-markdown>
                <script type="text/template">
<iframe width="853" height="480" data-src="https://www.youtube.com/embed/0GypdsJulKE?autoplay=1&controls=0&loop=1&playlist=0GypdsJulKE&showinfo=0"></iframe>

<aside class="notes"><p>Итак. Нам нужны интеграционные тесты на работу компонента/ов внутри формы. Так как мы используем React, то первое что может придти на ум, использовать популярную библиотеку для тестирования React компонентов Enzyme. Enzyme — это такая прикольная штука, которая существенно упрощает написание Unit тестов на компоненты, позволяет легко протестировать как ведет себя компонент при изменении props/state, вызовы life-cycle методов, разметку.</p>
</aside></script>
            </section>
            <section data-markdown>
                <script type="text/template">
## Enzyme

```typescript
it('Click the button', () => {
    const wrapper = mount(<AwesomeButton />)
	wrapper.find('button').simulate('click')
	// Тоже самое что и
	wrapper.find('button').prop('onClick')()

	// Работать не будет
	// wrapper.simulate('click')

    // ...
})
```

- Не честные клики, вызов `props.onClick`
- Завязка на внутреннюю разметку

<aside class="notes"><p>В каких случаях это плохо. Возьмем для примера DatePicker, компонент чуть более сложный, чем простой input. Внутри себя рисует input, передает ему в onChange свой обработчик, который в свою каким-то образом форматирует/парсит пользовательский ввод (позволяет вводить дату без точек) и вызывает onChange из props с модифицированным значением. Так вот simulate(&#39;change&#39;) ничто иное, как просто вызов onChange из props нашего DatePicker. Если нам нужно протестировать внутренний обработчик, то нам сначала нужно найти тот input и уже у него вызывать onChange. Попробуем зайти с другой стороны и возьмем уже инструмент для E2E тестирования, а именно TestCafe.</p>
</aside></script>
            </section>
            <section data-markdown>
                <script type="text/template">
## TestCafe

```typescript
test('Click the button', async t => {
    await t.click('[data-prop-tid=button]')
    // ...
})
```

- Удобная штука для e2e тестов
- Можно инжектить код на клиент
- Мокать и навешивать spy, слишком сложно

<aside class="notes"><p>Штука достаточно удобная. Поддержка TypeScript&#39;а, возможность использовать async/await, быстрый старт. Приятное API и встроенные ассерты. А самое главное, так как это инструмент для e2e тестов, честные клики. TestCafe в отличии от Selenium используется URL-Rewriting proxy. Это прокси инжектит специальные скрипты, которые эмулируют пользовательские действия. Но как и Selenium, писать интеграционные тесты с его помощью достаточно сложно. В виду того что нам необходимо проверять то как компонент взаимодействует с формой, а не форму целиком. Так как TestCafe внутри себя содержит скрипты позволяющие эмулировать пользовательские действия, почему бы нам не попробовать самим сделать что-то подобное с помощью DOM Events.</p>
</aside></script>
            </section>
            <section data-markdown>
                <script type="text/template">
## DOM Events

```typescript
it('Click the button', () => {
    const button = document
    	.querySelector('[data-prop-tid=button]')
    button.querySelector('button').click()
    // Или
    const event = new MouseEvent('click')
    button.querySelector('button').dispatchEvent(event)

    // ...
})
```

- Всплытие и tid навешивается на label
- Завязка на внутреннюю разметку

<aside class="notes"><p>Тут всё достаточно понятно. Более-менее честные клики, нет сложностей в написании интеграционных тестов, но нам снова как и с Enzyme приходится завязываться на внутренюю разметку компонентов. Кажется что выхода нет и мы вынуждены будем или писать кучу E2E тестов, которые будет больно поддерживать, они будут очень долго ходить и постоянно падать или полагаясь на unit тесты надеятся, что в результате очередного рефакторинга мы ничего не забыли и все модули правильно используют внутренее API друг друга. Но на самом деле не всё так плохо. Выход есть, и он называется Chrome DevTools Protocol</p>
</aside></script>
            </section>
            <section data-markdown>
                <script type="text/template">
## Chrome DevTools Protocol

Решение в лоб

<aside class="notes"><p>Что это такое?</p>
</aside></script>
            </section>
            <section data-markdown>
                <script type="text/template">
```typescript
const ws = new WebSocket(
    `ws://localhost:9222/devtools/page/${PageId}`)
const send = data =>
	ws.send(JSON.stringify({ id: uuid(), ...data }))
```

```typescript
send({method: 'DOM.getDocument', params: {}})
send({
    method: 'DOM.querySelector',
    params: {nodeId: 1, selector: '[data-prop-tid=button]'}})
```

```typescript
send({method: 'DOM.getBoxModel', params: { nodeId: 23 }})
send({
    method: 'Input.dispatchMouseEvent',
    params: { type: 'mousePressed', x: 40, y: 357,
               button: 'left', clickCount: 1 }})
send({
    method: 'Input.dispatchMouseEvent',
    params: { type: 'mouseReleased', x: 40, y: 357,
             button: 'left', clickCount: 1 }})
```
</script>
            </section>
            <section data-markdown>
                <script type="text/template">
## Puppeteer

- Хорошее и удобное API, но...
- Не работает в браузере из коробки

<aside class="notes"><p>Что это такое?</p>
</aside></script>
            </section>
            <section data-markdown>
                <script type="text/template">
## attachDevTools

```typescript
import { Connection } from 'puppeteer/lib/Connection'
import Browser from 'puppeteer/lib/Browser'
```

```typescript
const response =
    await fetch('http://localhost:9222/json/version')
const data = await response.json()
```

```typescript
const connection = await Connection
	.createForWebSocket(data.webSocketDebuggerUrl)
const browser = await Browser
    .create(connection, { appMode: true })
const pages = await browser.pages()
```

```typescript
// Disables network tracking,
// prevents network events from being sent to the client
// NOTE Because we don't want crash browser under events flood
pages.forEach(p => p._client.send('Network.disable', {}))
```
</script>
            </section>
            <section data-markdown>
                <script type="text/template">
```typescript
const page = await new Promise(resolve => {
  const expectedGuid = uuid()
  const findCurrentPage = index => async msg => {
    if (msg.type() != 'debug') return
    const [firstArg] = msg.args()
    const receivedGuid = await firstArg.jsonValue()
    if (receivedGuid == expectedGuid) {
      pages[index].removeAllListeners('console')
      resolve(pages[index])
    }
  }
  pages.forEach((p, index) =>
                p.on('console', findCurrentPage(index)))
  console.debug(expectedGuid)
})
```
</script>
            </section>
            <section data-markdown>
                <script type="text/template">
## PROFIT

- Удобное API
- Честные клики и не только
- Работает только в хроме
</script>
            </section>
            <section data-markdown>
                <script type="text/template">
## Bonus

```typescript
const promiseHandler = {
  apply(target, _thisArg, args) {
    return target().then(func => func(...args))
  },
  get(target, prop) {
    return new Proxy(() => target()
      .then(obj => obj[prop]), promiseHandler)
  },
}

const devtools = new Proxy(() => attachDevTools(),
                           promiseHandler)
```
</script>
            </section>
            <section data-markdown>
                <script type="text/template">
```typescript
it('Should dispatch action with value', async () => {
  const { form } = render(
      <DatePicker path={'a/b'} tid={'datepicker'} />)
  const selector = '[data-prop-tid=datepicker]'
  await devtools.click(selector)
  await devtools.type(selector, '23102018')
  await devtools.mouse.click(0, 0)

  expect(form.store.dispatch)
    .to.have.been.calledWithExactly({
      type: UPDATE_MODEL,
      payload: { path: 'a/b', field: 'value',
        value: '23.10.2018' },
    })
})
```
</script>
            </section>
            <section data-markdown>
                <script type="text/template">
## The End

\*TODO* QR, ссылки

https://martinfowler.com/bliki/TestPyramid.html

https://www.youtube.com/watch?v=0GypdsJulKE

<aside class="notes"><p>Вопросы. Почему button обернут в label — издержки ИЕ8, сейчас скорее всего это уже не нужно, надо проверять. Другой пример combobox, где input отображается в режиме редактирования. Необходимо для того чтобы рисовать значение состоящие из двух полей: код и наименование. data-prop атрибуты</p>
</aside></script>
            </section>
        </div>
    </div>

    <script src="./lib/js/head.min.js"></script>
    <script src="./js/reveal.js"></script>

    <script>
        function extend() {
            var target = {};
            for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        target[key] = source[key];
                    }
                }
            }
            return target;
        }

        // Optional libraries used to extend on reveal.js
        var deps = [
            { src: './lib/js/classList.js', condition: function () { return !document.body.classList; } },
            { src: './plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
            { src: './plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
            { src: './plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
            { src: './plugin/zoom-js/zoom.js', async: true },
            { src: './plugin/notes/notes.js', async: true },
            { src: './plugin/math/math.js', async: true }
        ];

        // default options to init reveal.js
        var defaultOptions = {
            controls: true,
            progress: true,
            history: true,
            center: true,
            transition: 'default', // none/fade/slide/convex/concave/zoom
            dependencies: deps
        };

        // options from URL query string
        var queryOptions = Reveal.getQueryHash() || {};

        var options = { "transition": "slide" };
        options = extend(defaultOptions, options, queryOptions);
    </script>


    <script>
        Reveal.initialize(options);
    </script>
</body>

</html>
